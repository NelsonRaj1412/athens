# This file includes code adapted from https://github.com/MElgul6/Pavshop
# Licensed under the MIT License
# Please use this code with caution and comply with the license terms.

from rest_framework import serializers
from .models import CustomUser, Project, UserDetail, CompanyDetail, AdminDetail
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
import random
import string

class ProjectSerializer(serializers.ModelSerializer):
    id = serializers.IntegerField(read_only=True)
    name = serializers.CharField(source='projectName')
    category = serializers.ChoiceField(source='projectCategory', choices=Project.CATEGORY_CHOICES)
    policeStation = serializers.CharField(source='nearestPoliceStation')
    policeContact = serializers.CharField(source='nearestPoliceStationContact')
    hospital = serializers.CharField(source='nearestHospital')
    hospitalContact = serializers.CharField(source='nearestHospitalContact')
    capacity = serializers.CharField()
    location = serializers.CharField()
    latitude = serializers.FloatField(required=False, allow_null=True)
    longitude = serializers.FloatField(required=False, allow_null=True)
    commencementDate = serializers.DateField()
    deadlineDate = serializers.DateField(required=True)

    class Meta:
        model = Project
        fields = [
            'id',
            'name',
            'category',
            'capacity',
            'location',
            'latitude',
            'longitude',
            'policeStation',
            'policeContact',
            'hospital',
            'hospitalContact',
            'commencementDate',
            'deadlineDate',
        ]

# In authentication/serializers.py

class CustomUserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=False)
    user_type = serializers.CharField(required=False)
    project = serializers.PrimaryKeyRelatedField(queryset=Project.objects.all(), required=False, allow_null=True)
    created_by = serializers.PrimaryKeyRelatedField(read_only=True, required=False)

    class Meta:
        model = CustomUser
        fields = [
            'id',
            'username',
            'email',
            'user_type',
            'project',
            'admin_type',
            'company_name',
            'registered_address',
            'name',
            'surname',
            'department',
            'designation',
            'grade',
            'phone_number',
            'created_by',
            'password',
            'is_autogenerated_password',
            'is_password_reset_required',
        ]
        read_only_fields = ['is_autogenerated_password', 'is_password_reset_required', 'created_by']

    def validate(self, attrs):
        # Only require password on create, not on update
        if self.instance is None and 'password' not in attrs:
            # If password not provided, allow backend to generate it
            pass
        return attrs

    # --- THIS IS THE ONLY PART THAT CHANGES ---
    def create(self, validated_data):
        import logging
        import random
        import string
        logger = logging.getLogger(__name__)

        # 1. Pop the password from the data. If it's not there, we'll generate one.
        password = validated_data.pop('password', None)
        
        # 2. If 'grade' wasn't provided, determine it from designation.
        if 'grade' not in validated_data:
            designation = validated_data.get('designation', '').lower()
            if designation == 'siteincharge':
                validated_data['grade'] = 'A'
            elif designation in ['teamleader', 'manager']:
                validated_data['grade'] = 'B'
            else:
                validated_data['grade'] = 'C'

        # 3. Generate a secure password if one wasn't provided.
        autogenerated = False
        if not password:
            password = ''.join(random.choices(string.ascii_letters + string.digits + '!@#$%^&*', k=16))
            autogenerated = True

        # 4. Use the model manager's `create_user` method.
        # This is the most reliable way to create a user. It takes the password separately
        # and handles all other fields from validated_data, including project and company_name.
        user = CustomUser.objects.create_user(
            password=password,
            **validated_data
        )

        # 5. Set the password-related flags on the newly created user object.
        if autogenerated:
            user.is_autogenerated_password = True
            user.is_password_reset_required = True
        
        user.save() # Save the flag changes.

        # 6. Attach the plain password for the response, as before.
        user._plain_password = password
        
        logger.debug(f"User {user.username} created with project ID: {user.project_id} and company: {user.company_name}")

        return user
    # --- END OF THE CHANGED PART ---
        
    def update(self, instance, validated_data):
        # If grade is not provided but designation is being updated, determine grade
        if 'grade' not in validated_data and 'designation' in validated_data:
            designation = validated_data.get('designation', '').lower()
            if designation == 'siteincharge':
                validated_data['grade'] = 'A'
            elif designation in ['teamleader', 'manager']:
                validated_data['grade'] = 'B'
            else:
                # For custom designations or other standard designations, default to Grade C
                validated_data['grade'] = 'C'
                
        return super().update(instance, validated_data)

class UserDetailSerializer(serializers.ModelSerializer):
    name = serializers.CharField(source='user.name', read_only=True)
    surname = serializers.CharField(source='user.surname', read_only=True)
    designation = serializers.CharField(source='user.designation', read_only=True)
    department = serializers.CharField(source='user.department', read_only=True)
    email = serializers.EmailField(source='user.email', read_only=True)
    
    # --- FIX: ADD THIS FIELD ---
    # This field fetches the ID of the user who created the user associated with this UserDetail instance.
    created_by = serializers.ReadOnlyField(source='user.created_by.id', allow_null=True)

    class Meta:
        model = UserDetail
        fields = [
            'id',
            'created_by',
            'user',
            'employee_id',
            'gender',
            'father_or_spouse_name',
            'date_of_birth',
            'nationality',
            'education_level',
            'date_of_joining',
            'mobile',
            'uan',
            'pan',
            'pan_attachment',
            'aadhaar',
            'aadhaar_attachment',
            'mark_of_identification',
            'photo',
            'specimen_signature',
            'signature_template',
            'signature_template_data',
            'is_approved',
            'approved_by',
            'approved_at',
            'created_at',
            'updated_at',
            'name',
            'surname',
            'designation',
            'department',
            'email',
        ]
        read_only_fields = ['user', 'signature_template', 'signature_template_data', 'is_approved', 'approved_by', 'approved_at', 'created_at', 'updated_at',
                            'name', 'surname', 'designation', 'department', 'email']

import logging
logger = logging.getLogger(__name__)

class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    def validate(self, attrs):
        logger.debug(f"Validating token obtain pair for username: {attrs.get('username')}")
        
        # Use Django's built-in authentication but handle password validation more gracefully
        try:
            data = super().validate(attrs)
        except Exception as e:
            logger.error(f"Authentication failed for {attrs.get('username')}: {str(e)}")
            raise
            
        user = self.user.__class__.objects.get(pk=self.user.pk)
        
        # Check user_type first, then admin_type
        # Handle master users - both user_type='master' and admin_type='master'
        if user.user_type == 'master' or (user.user_type == 'projectadmin' and user.admin_type == 'master'):
            data['usertype'] = 'master'
            data['username'] = user.username
        elif user.user_type in ['superadmin', 'masteradmin']:
            data['usertype'] = 'MASTER_ADMIN'
            data['username'] = user.username
        elif user.user_type == 'projectadmin':
            # For multiple contractor admins, append index to usertype if admin_type is contractor
            if user.admin_type == 'contractor':
                # Attempt to find index of this contractor admin among all contractor admins in the project
                if user.project:  # Only if user has a project
                    contractor_admins = CustomUser.objects.filter(project=user.project, user_type='projectadmin', admin_type='contractor').order_by('id')
                    index = None
                    for i, admin in enumerate(contractor_admins, start=1):
                        if admin.pk == user.pk:
                            index = i
                            break
                    if index:
                        data['usertype'] = f'contractor{index}'
                    else:
                        data['usertype'] = user.admin_type
                else:
                    data['usertype'] = user.admin_type
                data['username'] = user.username
            else:
                data['usertype'] = user.admin_type
                data['username'] = user.username
        elif user.user_type == 'adminuser':
            data['usertype'] = user.admin_type
            data['username'] = user.email
        else:
            # Fallback for other user types
            data['usertype'] = getattr(user, 'user_type', 'user')
            data['username'] = getattr(user, 'username', None)
        data['isPasswordResetRequired'] = getattr(user, 'is_password_reset_required', False)
        data['user_id'] = user.id
        data['django_user_type'] = user.user_type  # <-- Add this line
        data['grade'] = getattr(user, 'grade', None)  # Add grade field
        data['department'] = getattr(user, 'department', None)  # Add department field
        # Add project_id to token response if user has a project
        if user.project:
            data['project_id'] = user.project.id
        else:
            data['project_id'] = None

        # Add approval status for users who need approval
        data['is_approved'] = True  # Default to approved
        data['has_submitted_details'] = True  # Default to submitted

        # Master users are always approved and don't need to submit details
        if user.user_type == 'master' or (user.user_type == 'projectadmin' and user.admin_type == 'master'):
            data['is_approved'] = True
            data['has_submitted_details'] = True
        elif user.user_type == 'projectadmin':
            try:
                admin_detail = user.admin_detail
                data['has_submitted_details'] = bool(
                    admin_detail.phone_number and
                    admin_detail.pan_number and
                    admin_detail.gst_number
                )
                data['is_approved'] = admin_detail.is_approved
            except:
                data['has_submitted_details'] = False
                data['is_approved'] = False

        elif user.user_type == 'adminuser':
            try:
                user_detail = user.user_detail
                data['has_submitted_details'] = bool(
                    user_detail.mobile and
                    user_detail.pan and
                    user_detail.employee_id
                )
                data['is_approved'] = user_detail.is_approved
            except:
                data['has_submitted_details'] = False
                data['is_approved'] = False

        return data

class CompanyDetailSerializer(serializers.ModelSerializer):
    """
    Serializer for the CompanyDetail model, correctly handling file uploads.
    """
    # --- THIS IS THE CRITICAL FIX ---
    # This explicitly defines 'company_logo' as an image field, making it optional.
    company_logo = serializers.ImageField(required=False, allow_null=True, max_length=None, use_url=True)

    # Make all fields optional for partial updates
    company_name = serializers.CharField(required=False, allow_blank=True)
    registered_office_address = serializers.CharField(required=False, allow_blank=True)
    pan = serializers.CharField(required=False, allow_blank=True)
    gst = serializers.CharField(required=False, allow_blank=True)
    contact_phone = serializers.CharField(required=False, allow_blank=True)
    contact_email = serializers.EmailField(required=False, allow_blank=True)

    class Meta:
        model = CompanyDetail
        fields = [
            'id',
            'user',
            'company_name',
            'registered_office_address',
            'pan',
            'gst',
            'company_logo',  # Now correctly handled by the ImageField above
            'contact_phone',
            'contact_email',
            'project_capacity_completed',
            'project_capacity_ongoing',
            'created_at',
            'updated_at',
        ]
        read_only_fields = ['user', 'created_at', 'updated_at']

    def to_representation(self, instance):
        """
        Customize the output to return the full URL for the logo.
        This is crucial for the React frontend to display the image correctly after saving.
        """
        representation = super().to_representation(instance)
        # Check if the company_logo field exists and has a value
        if instance.company_logo:
            request = self.context.get('request')
            if request is not None:
                # This creates the full path, e.g., "http://localhost:8000/media/logos/my_logo.png"
                representation['company_logo'] = request.build_absolute_uri(instance.company_logo.url)
            else:
                # Fallback for contexts without a request object
                representation['company_logo'] = instance.company_logo.url
        return representation

class MasterAdminSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=True)

    class Meta:
        model = CustomUser
        fields = ['username', 'email', 'password']
        
    def create(self, validated_data):
        user = CustomUser(
            username=validated_data['username'],
            email=validated_data.get('email'),
            user_type='projectadmin',
            admin_type='master',
            is_autogenerated_password=False,
            is_password_reset_required=False,
            is_active=True,
            is_staff=True,
        )
        user.set_password(validated_data['password'])
        user.save()
        from django.contrib.auth.models import Permission
        all_permissions = Permission.objects.all()
        user.user_permissions.set(all_permissions)
        return user

class AdminUserCommonSerializer(serializers.ModelSerializer):
    project = ProjectSerializer(read_only=True)
    company_name = serializers.SerializerMethodField()
    signature = serializers.SerializerMethodField()

    class Meta:
        model = CustomUser
        fields = [
            'id',
            'username',
            'email',
            'user_type',
            'project',
            'admin_type',
            'company_name',
            'registered_address',
            'name',
            'surname',
            'department',
            'designation',
            'grade',
            'phone_number',
            'created_by',
            'signature',
        ]
        read_only_fields = ['created_by']

    def get_company_name(self, obj):
        import logging
        logger = logging.getLogger(__name__)
        logger.debug(f"Serializing company_name for user {obj.username}: obj.company_name={obj.company_name}")
        if obj.created_by:
            logger.debug(f"User {obj.username} created_by.company_name={getattr(obj.created_by, 'company_name', None)}")
        if hasattr(obj, 'company_detail') and obj.company_detail:
            logger.debug(f"User {obj.username} company_detail.company_name={getattr(obj.company_detail, 'company_name', None)}")

        if obj.company_name:
            return obj.company_name
        elif obj.created_by and obj.created_by.company_name:
            return obj.created_by.company_name
        elif hasattr(obj, 'company_detail') and obj.company_detail and obj.company_detail.company_name:
            return obj.company_detail.company_name
        return None

    def get_signature(self, obj):
        import logging
        logger = logging.getLogger(__name__)
        if hasattr(obj, 'user_detail') and obj.user_detail and obj.user_detail.specimen_signature:
            logger.debug(f"Serializing signature for user {obj.username}: specimen_signature={obj.user_detail.specimen_signature}")
            request = self.context.get('request', None)
            signature = obj.user_detail.specimen_signature
            if request is not None:
                return request.build_absolute_uri(signature.url)
            else:
                return signature.url
        logger.debug(f"No signature found for user {obj.username}")
        return None

class AdminDetailSerializer(serializers.ModelSerializer):
    photo = serializers.ImageField(required=False, allow_null=True, max_length=None, use_url=True)
    logo = serializers.ImageField(required=False, allow_null=True, max_length=None, use_url=True)
    
    class Meta:
        model = AdminDetail
        fields = [
            'id',
            'user',
            'name',
            'phone_number',
            'pan_number',
            'gst_number',
            'photo',
            'logo',
            'signature_template',
            'signature_template_data',
            'created_at',
            'updated_at',
        ]
        read_only_fields = ['user', 'signature_template', 'signature_template_data', 'created_at', 'updated_at']
    
    def to_representation(self, instance):
        """
        Customize the output to return the full URL for photo and logo.
        This ensures the React frontend can display the images correctly.
        """
        representation = super().to_representation(instance)
        
        # Handle photo URL
        if instance.photo:
            request = self.context.get('request')
            if request is not None:
                representation['photo'] = request.build_absolute_uri(instance.photo.url)
            else:
                representation['photo'] = instance.photo.url
        
        # Handle logo URL
        if instance.logo:
            request = self.context.get('request')
            if request is not None:
                representation['logo'] = request.build_absolute_uri(instance.logo.url)
            else:
                representation['logo'] = instance.logo.url
        
        return representation

